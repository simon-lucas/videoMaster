package com.studioshitless.GraphicTimers{/*	PIE CLOCKTIMER 	copyright Studio Shitless 2008-2012		USAGE	pie=new PieTimer();	addChild(pie);		var rad:uint=100;	var time:uint=20 //time in secs	var colour:String= "0xFF0000" //clock colour	var radius:uint// radius	var timesUp:Function //AS2 style callback!	pie.startTimer(time, colour, radius, timesUp);*/import flash.display.Sprite;import flash.events.Event;import flash.utils.getTimer;import flash.display.Shape;public class PieTimer extends Sprite{	public var radius:Number;	public var start_radius:Number;	public var time:Number;	public var end_time:Number;	public var timer:Number;	public var timeInterval:Number;	public var inc:Number;	public var rad_inc:Number;	public var accuracy:Number;	public var degrees:Number;	//ALRAM	public var alarmdegrees:Number;	public var alarmtimer:Number;	public var alarmInterval:Number;	public var alarmState:Boolean;	public var alarmactivated:Boolean;	//COLOUR	public var colour:String;	public var callback:Function;			public var clockShape:Shape; 		public function PieTimer()	{		super();		this.degrees = 360;		this.accuracy = 10;		this.timeInterval = 10;		this.alarmactivated=false;		this.alarmInterval = 500;	}	public function startTimer(time:Number, colour:String, radius:Number, callback:Function):void {				//*********************		//***** RESET ALRM*********		this.alarmState = false;		this.alpha=100;		this.alarmactivated=false;		//*************************		this.callback = callback;		this.time = time;		this.end_time = getTimer() + (this.time * 1000);		this.colour = colour;		this.radius = radius;		this.start_radius = radius;		this.degrees = 360;		//this.inc = (360 * this.timeInterval / 1000) / time;				this.rad_inc = (this.radius / 2 * this.timeInterval / 1000) / time;		this.timer = getTimer() + this.timeInterval;		var X = 4 / this.time * 360;		this.alarmdegrees = Math.min(360 / 4, X);		//trace("start timer alarm is" +this.alarmactivated);		//trace("this.alarmactivated is " +this.alarmactivated);		//trace("this.alarmdegrees are "+this.alarmdegrees);		addEventListener(Event.ENTER_FRAME,enterFrameHandler)				clockShape = new Shape();		addChild(clockShape)	}		public function enterFrameHandler(e:Event):void{		//trace(this.degrees);		if (this.timer < getTimer()) {			this.degrees = 360 * (this.end_time - getTimer()) / (this.time*1000);						if (this.degrees > 0) {				this.Wedge(this.radius, 0, this.degrees, 0);			} else {				this.Wedge(this.radius, 0, 0, 0);				//trace(this.callback);				if (callback!=null){					this.callback();				}								removeEventListener(Event.ENTER_FRAME,enterFrameHandler);			}			this.timer = getTimer() + this.timeInterval;			this.radius -= this.rad_inc;			this.radius = Math.max(this.radius, this.start_radius / 2);		}		if (!this.alarmactivated) {			//CHECK ALARM TIME DEGREES			if (this.degrees  < this.alarmdegrees) {				//trace("start alam!!!!");				//trace("this.alarmdegrees "+this.degrees+" "+this.alarmdegrees);				this.alarmactivated = true;				this.alarmtimer = getTimer() + this.alarmInterval;			}		} else if (this.alarmactivated){			//ALRM IS ON SO PULSE			if (this.alarmtimer < getTimer()) {				this.alarmtimer = getTimer() + this.alarmInterval;				this.alpha = [0, 1][Number(this.alarmState)];				//this._xscale = this._yscale= [100,110][Number(this.alarmState)];				this.alarmState = !this.alarmState;			}		}			}	//called by wedge	private function drawCircle(x, y, radius, angle, rotation, dir) {		if (dir == 1) {			angle = 0 - angle;			rotation = rotation - angle;		}		var span = (Math.PI / (360 / angle)) / this.accuracy;		var controlRadius = this.radius / Math.cos(span);		var anchorAngle = Math.PI * ((rotation - 90) / 180);		var controlAngle = Math.PI * ((rotation - 90) / 180);		for (var i = 0; i < this.accuracy; ++i) {			controlAngle = anchorAngle + span;			anchorAngle = controlAngle + span;			clockShape.graphics.curveTo(x + Math.cos(controlAngle) * controlRadius, y + Math.sin(controlAngle) * controlRadius, x + Math.cos(anchorAngle) * this.radius, y + Math.sin(anchorAngle) * this.radius);		}	}	//called by the enterframe fucntion at end_timer	private function Wedge(Wradius1, Wradius2, Wangle, Wrotation) {		clockShape.graphics.clear();		clockShape.graphics.beginFill(Number(this.colour));		clockShape.graphics.moveTo(Math.cos(Math.PI * ((Wrotation - 90) / 180)) * Wradius1, Math.sin(Math.PI * ((Wrotation - 90) / 180)) * Wradius1);		drawCircle(0, 0, Wradius1, Wangle, Wrotation, 0);		clockShape.graphics.lineTo(Math.cos(Math.PI * ((Wrotation - 90 + Wangle) / 180)) * Wradius2, Math.sin(Math.PI * ((Wrotation - 90 + Wangle) / 180)) * Wradius2);		//this.DrawCircle(0, 0, Wradius2, Wangle, Wrotation, 1);		clockShape.graphics.lineTo(Math.cos(Math.PI * ((Wrotation - 90) / 180)) * Wradius1, Math.sin(Math.PI * ((Wrotation - 90) / 180)) * Wradius1);	}}}