package com.studioshitless.GraphicTimers{/*	PIE CLOCKTIMER 	copyright Studio Shitless 2008-2012		USAGE	pie=new PieTimer();	addChild(pie);		var rad:uint=100;	var time:uint=20 //time in secs	var colour:String= "0xFF0000" //clock colour	var radius:uint// radius	var timesUp:Function //AS2 style callback!	pie.startTimer(time, colour, radius, timesUp);*/import flash.display.Sprite;import flash.events.Event;import flash.utils.getTimer;import flash.display.Shape;public class PlainPie extends Sprite{	public var radius:Number;	public var start_radius:Number;	public var time:Number;	public var end_time:Number;	public var timer:Number;	public var timeInterval:Number;	public var inc:Number;	public var rad_inc:Number;	public var accuracy:Number;	public var degrees:Number;	//COLOUR	public var colour:String;	public var callback:Function;			public var clockShape:Shape; 		public function PlainPie()	{		super();		this.degrees = 360;		this.accuracy = 10;		this.timeInterval = 10;				clockShape = new Shape();		addChild(clockShape)	}		public function init(colour:String, radius:Number):void{		this.alpha=100;		this.colour = colour;		this.radius = radius;	}		public function startTimer(time:Number, colour:String, radius:Number, callback:Function):void {				//*********************		//***** RESET *********		this.alpha=100;		this.callback=callback;		this.time = time;		this.end_time = getTimer() + (this.time * 1000);		this.colour = colour;		this.radius = radius;		this.start_radius = radius;		this.degrees = 360;		//this.inc = (360 * this.timeInterval / 1000) / time;				this.timer = getTimer() + this.timeInterval;		var X = 4 / this.time * 360;		//trace("start timer alarm is" +this.alarmactivated);		//trace("this.alarmactivated is " +this.alarmactivated);		//trace("this.alarmdegrees are "+this.alarmdegrees);		addEventListener(Event.ENTER_FRAME,enterFrameHandler)			}	/*	**** setDegrees ****	* this is used when not running as timer	* it draws a positive shape the size of the degrees in the set color	* NB. Because normally the pie shape starts full and the current degrees are the blank shape subtracted	*/	public function setDegrees(degrees:int):void{		this.degrees= 360-degrees		if (this.degrees > 0) {			this.Wedge(this.radius, 0, 360-this.degrees, 0);		} else {			this.Wedge(this.radius, 0, 360, 0);			}	}		public function enterFrameHandler(e:Event):void{		//trace(this.degrees);		if (this.timer < getTimer()) {			this.degrees = 360 * (this.end_time - getTimer()) / (this.time*1000);						if (this.degrees > 0) {				this.Wedge(this.radius, 0, 360-this.degrees, 0);			} else {				this.Wedge(this.radius, 0, 360, 0);					callback()				removeEventListener(Event.ENTER_FRAME,enterFrameHandler);			}			this.timer = getTimer() + this.timeInterval;		}					}	//called by wedge	private function drawCircle(x, y, radius, angle, rotation, dir) {		if (dir == 1) {			angle = 0 - angle;			rotation = rotation - angle;		}		var span = (Math.PI / (360 / angle)) / this.accuracy;		var controlRadius = this.radius / Math.cos(span);		var anchorAngle = Math.PI * ((rotation - 90) / 180);		var controlAngle = Math.PI * ((rotation - 90) / 180);		for (var i = 0; i < this.accuracy; ++i) {			controlAngle = anchorAngle + span;			anchorAngle = controlAngle + span;			clockShape.graphics.curveTo(x + Math.cos(controlAngle) * controlRadius, y + Math.sin(controlAngle) * controlRadius, x + Math.cos(anchorAngle) * this.radius, y + Math.sin(anchorAngle) * this.radius);		}	}	//called by the enterframe fucntion at end_timer	private function Wedge(Wradius1, Wradius2, Wangle, Wrotation) {				clockShape.graphics.clear();		clockShape.graphics.beginFill(Number(this.colour));		clockShape.graphics.moveTo(Math.cos(Math.PI * ((Wrotation - 90) / 180)) * Wradius1, Math.sin(Math.PI * ((Wrotation - 90) / 180)) * Wradius1);		drawCircle(0, 0, Wradius1, Wangle, Wrotation, 0);		clockShape.graphics.lineTo(Math.cos(Math.PI * ((Wrotation - 90 + Wangle) / 180)) * Wradius2, Math.sin(Math.PI * ((Wrotation - 90 + Wangle) / 180)) * Wradius2);		//this.DrawCircle(0, 0, Wradius2, Wangle, Wrotation, 1);		clockShape.graphics.lineTo(Math.cos(Math.PI * ((Wrotation - 90) / 180)) * Wradius1, Math.sin(Math.PI * ((Wrotation - 90) / 180)) * Wradius1);	}}}