package com.studioshitless.ImageGridEngine{import flash.display.Sprite;import com.studioshitless.Utilities.DrawLineRectangle;import flash.geom.Point;import flash.utils.Dictionary;import com.studioshitless.views.ImageLoader;import com.studioshitless.Utilities.DrawRectangle;import flash.utils.setTimeout;import com.studioshitless.views.MaskedImage;import com.studioshitless.events.MaskedImageEvent;public class ImageGrid extends ImageGridBase implements IImageGrid{	public var cols:uint;	public var rows:uint;	public var gridH:uint;	public var gridW:uint;	public var grid:Array;	public var squaresList:Vector.<Point>;	public var pointDict:Dictionary;	public var startSize:uint=3;	public var maxImages:uint=3;	public var ratio:String;		public function ImageGrid(w:uint, h:uint, cols:uint=6, rows:uint=4)	{		super(w,h);		this.cols=cols;		this.rows=rows;		gridH=h/rows;		gridW=w/cols;		//trace(gridW,gridH)	}		public override function init(imageList:Array, startSize:uint=0):void{		super.init(imageList);		maxImages=Math.min(imageList.length,maxImages);// set maximum images		grid = new Array();		squaresList= new Vector.<Point>();		pointDict = new Dictionary()		for (var gRow:uint=0; gRow< rows; gRow++){			var aRow:Array = new Array();			for (var gCol:uint=0; gCol< cols; gCol++){				if (showGrid){					drawGrid(gCol,gRow);				}				var p:Point= new Point(gCol,gRow);				aRow.push(p)//fill with EMPTY				pointDict[p]="EMPTY";				if (maxImages > 4){				if (p.x==0 && p.y==0) pointDict[p]="FULL";				if (p.x==cols-1 && p.y==0) pointDict[p]="FULL";				if (p.x==0 && p.y==rows-1) pointDict[p]="FULL";				if (p.x==cols-1 && p.y==rows-1) pointDict[p]="FULL";					}				squaresList.push(p)			}			grid.push(aRow);					}		counter=0;		//	addChild(imageList[counter])		//trace("this.startSize",this.startSize,startSize)		if (startSize>0) this.startSize=startSize;		//trace("this.startSize",this.startSize)		guessStartSize();		addImage()		//checkGrid()	}		public function drawGrid(gCol:uint, gRow:uint):void{		var r:DrawLineRectangle = new DrawLineRectangle(0,0,gridW,gridH,0xFFFFFF, 0x336699);		addChild(r)		r.x=gCol*gridW		r.y=gRow*gridH;	}	public function guessStartSize():void{		//trace("start length", maxImages)		switch (maxImages){			case 1:			startSize=cols;			break;			case 2:			startSize=cols;			break;			case 3:			startSize=cols;			break;			case 4:			startSize=rows;			break;			case 5:			startSize=3;			break;			default:			startSize=2;		}	}			public function checkGrid():void{			var gridString:String="";			for (var gRow:uint=0; gRow< rows; gRow++){				var aRow:Array = grid[gRow];				var r:String="";				for (var gCol:uint=0; gCol< cols; gCol++){					var p:Point=aRow[gCol];					var res:String=p.x+":"+p.y;					if (gCol<cols-1) r+=(res + ",") else r+=(res)									}					gridString+=(r+"\n")			}						root["gridtext"].text+=gridString+"\n\n"				}		public function printGrid():void{			var gridString:String="";			for (var gRow:uint=0; gRow< rows; gRow++){				var aRow:Array = grid[gRow];				var r:String="";				for (var gCol:uint=0; gCol< cols; gCol++){					var p:Point=aRow[gCol];					var res:String= (pointDict[p]=="FULL" ? "X":"0")					if (gCol<cols-1) r+=(res + ",") else r+=(res)									}					gridString+=(r+"\n")			}						root["gridtext"].text+=gridString+"\n\n";				}			public override function addImage():void{		if (startSize>0 && counter< maxImages){		//printGrid()		//trace("startSize", startSize)		var sizeH:uint;		var sizeV:uint;					if (imageList[counter].ratio > 1.2){				ratio="landscape";				if (startSize>1){					sizeH=startSize					sizeV=startSize/2								}else{					sizeH=startSize					sizeV=startSize								}			} else if (imageList[counter].ratio < 0.8){				ratio="portrait";				if (startSize>1){					sizeH=startSize/2					sizeV=startSize								}else{					sizeH=startSize					sizeV=startSize								}			} else {				ratio="square";				sizeH=startSize				sizeV=startSize			}					var p:Point;			p=findSquare(sizeH,sizeV);		//	trace("use", p)			if (p) {				showImageAt(p,sizeH,sizeV)				counter++				setTimeout(addImage,250)			}else{				startSize--;				setTimeout(addImage,250)				trace("go smaller")			}		}else{			trace("no no no")		}		printGrid()		}			public function showImageAt(p,ww,hh){				var i:MaskedImage=imageList[counter];				i.scaleTo(gridW*ww,gridH*hh);		i.x=p.x*gridW;		i.y=p.y*gridH;		addChild(i)		i.addEventListener(MaskedImageEvent.ZOOM,onImageZoomed,false);			}			public function findSquare(w, h):Point{		var pp:Point = new Point(0,0);		var pointList:Array= new Array();		for each (var p:Point in squaresList){			if (testASquare(p,w,h)) pointList.push(p);		}				if (pointList.length>0) {			pp = pointList[Math.floor(Math.random()*pointList.length)]			//trace("set fill",pp.x,pp.y)			setFullP(pp,w,h)		}else{			pp=null;		}		return pp;	}		public function testASquare(p:Point,w:uint,h:uint):Boolean	{		var empty:Boolean=true;//assume empty		var startCol:uint=p.x		var startRow:uint=p.y		//trace("testing col:",startCol, "row:", startRow)		/* go through all the squares in the requested grid area*/		var sizeH=startSize-1;		var sizeW=startSize-1;		if ((startRow+sizeH)<grid.length && (startCol+sizeW)<grid[0].length){			for (var col:uint=startCol; col < p.x + w; col++ ){				for (var row: uint = startRow ; row < p.y + h ; row ++){				//	trace("do this", col, row, grid.length, grid[0].length)					var pp:Point=grid[row][col];					/* test the point if any is full then abort cols */					if (pointDict[pp] == "FULL"){						empty=false;						break;					}				}				if (!empty) break; // we've already found one full in this row so abort			}		}else{			empty=false;		}		return empty;	}	public function setFullP(p:Point,w:uint,h:uint):void{		//trace("setFullP ", p.x,p.y)		var pointSquares:Array=[];		for (var col:uint=p.x; col < p.x + w; col++ ){			for (var row: uint = p.y ; row < p.y + h ; row ++){				//trace("do this", col, row)				var pp:Point=grid[row][col];				/* save the piint */				//pointSquares.push(grid[row][col])				/* set the point to full */				pointDict[pp] = "FULL"			}		}	}	}}