//	VideoPlayer(copy) 1.1 updated by SImon//	updated OCT 2012 - Uses VideoCueEvent Dispatcher.//	If using progress bar. video mc needs videoMc.bar and videoMc.barBg//	Cue points : onMetaData, and onCuePoints//	for audio cue points, make markers in sound boooth and export as flv without video./* NB/ v1.1 ONLY RESPONDS TO navigation cue points*/package  com.studioshitless.views {		import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.events.AsyncErrorEvent;			import flash.display.MovieClip;		import flash.net.NetStream;		import flash.net.NetConnection;		import flash.media.Video;		import flash.media.SoundTransform;		import flash.events.NetStatusEvent;		import flash.display.Sprite;		import com.spiral.events.VideoCueEvent;	import com.spiral.events.VideoEvent;	import com.spiral.events.VideoEventZ;	public class VideoPlayer extends Sprite {		private var videoPath : String;		private var video : Video = null;		private var mySound : SoundTransform;		private var connection : NetConnection;		private var stream_ns : NetStream;		//		private var bar:MovieClip;		private var barBg:MovieClip;		private var vWidth : Number;		private var vHeight : Number;		private var videoX : Number;		private var videoY : Number;		private var cuePointsList : Array;		private var isLoop : Boolean;		private var progressTimer : Timer;		private var metadata : Object;		private var debug :Boolean = false;				private var navigationPoints:Array;		public var cuePointCount:uint=0;		public var currentCueIndex:uint;				public function VideoPlayer(vWidth : Number, vHeight : Number,videoX : Number, videoY : Number) {			this.vWidth = vWidth;			this.vHeight = vHeight;			this.videoX = videoX;			this.videoY = videoY;			navigationPoints=new Array();			////for progress bar			progressTimer = new Timer(100);			progressTimer.addEventListener(TimerEvent.TIMER, onTick, false, 0, true);			initStream();		}				/* PUBLIC INTERFACE */		public function setMovie(videoPath : String) : void {			video.visible=false;			this.videoPath=videoPath;			stream_ns.play(videoPath);			stream_ns.pause();			stream_ns.seek(0);			if(contains(video) == false) {				//if (debug) trace("VideoPlayer:add video "+videoPath);				addChild(video);			}			video.visible=true;		}				public function playMovie(isLoop:Boolean=false) : void {			isLoop=isLoop;			stream_ns.play(videoPath);		}				/* PRIVATE INTERFACE */				private function initStream() : void {			connection = new NetConnection();            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);            connection.connect(null);			var customClient : Object = new Object();			customClient.onMetaData = metaDataHandler;			customClient.onCuePoint = navigationCuePointHandler;						stream_ns = new NetStream(connection);			stream_ns.client = customClient;			stream_ns.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);			stream_ns.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);			createVideo();		}		private function createVideo() : void {			if(video == null) {				video = new Video();				if (debug) trace("VideoPlayer:mew video!");			}						video.x = videoX;			video.y = videoY;			video.width = vWidth;			video.height = vHeight;			video.smoothing = true;				video.attachNetStream(stream_ns);			mySound = stream_ns.soundTransform;			adjustVolume(1);		}		private function asyncErrorHandler(event : AsyncErrorEvent) : void {			//trace("asyncErrorHandler"+event.text);		}		private function netStatusHandler(event : NetStatusEvent) : void {			trace("netStatusHandler "+event.info.code);			if(event.info.code == "NetStream.FileStructureInvalid") {				//bug.appendText("The MP4's file structure is invalid.");			}else if(event.info.code == "NetStream.NoSupportedTrackFound") {				//bug.appendText("The MP4 doesn't contain any supported tracks");			}else if(event.info.code == "NetStream.Buffer.Flush") {				//bug.appendText("flucsh");			}else if(event.info.code =="NetStream.Buffer.Full"){				//trace("NetStream.Buffer.Full");				//stream_ns.togglePause();				//stream_ns.seek(0);			}else if(event.info.code == "NetStream.Play.Stop") {				trace("VideoPlayer:videoplayer internal stop");				if(video != null) {					if(this.contains(video)) {						stream_ns.pause();						endVideo();					}				}			}		}		private function endVideo() : void {			//			if(isLoop){				trace("loop")				stream_ns.seek(0);				stream_ns.resume();			}else{				trace("donbt loop")				dispatchEvent(new VideoEventZ(VideoEventZ.VIDEO_STOP));			}			progressTimer.stop();			if(bar){				bar.width =barBg.width;			}					}		private function navigationCuePointHandler(infoObject : Object) : void {			//if (debug) trace("VideoPlayer:cuePoints",infoObject);			if (debug){				var key : String; 				for (key in infoObject) { 					trace(key + "::: " + infoObject[key]); 				}							}			if (infoObject.type == "navigation"){				for (var i:uint=0; i < navigationPoints.length; i++ ){					if (infoObject.time==navigationPoints[i]){						currentCueIndex=i;						if (debug) trace("Current cue is: ",currentCueIndex)						break;					}				}				/////Dispatch event here				var navCuePointEvt= new VideoCueEvent(VideoCueEvent.ON_NAVCUEPOINT);				navCuePointEvt.cueIndex = currentCueIndex;				dispatchEvent(navCuePointEvt);			}		}		private function metaDataHandler(infoObject : Object) : void {						cuePointsList = new Array();			metadata=infoObject; //save the metadata			if (debug) {				trace("VideoPlayer:metaDataHandler");				var item : *; 				for (item in infoObject) { 						//trace( ": " + infoObject[item]); 				}			} 			 			/** CREATE A LIST OF NAVIGATION CUE POINTS AND THEIR TIMES **/			for(var i : Number = 0;i < infoObject.cuePoints.length; i++) {				var oCue : Object = infoObject.cuePoints[i];				if (debug) trace("\t\t" + i + ": " + oCue.name + ", " + oCue.type+ ", " + oCue.time+ ", " + oCue.parameters);				if (oCue.type == "navigation"){					//trace("ADD", oCue.time)					navigationPoints.push(oCue.time);				}			}			cuePointCount=navigationPoints.length;			initProgressBar();		}		private function initProgressBar() : void {			// Progress bar movieclip contains 'bar' and 'barBg'			if (bar) {				bar.width =0.1;				progressTimer.start();			}		}		private function onTick(event : TimerEvent) : void {			if(metadata){				bar.width = stream_ns.time / metadata.duration * barBg.width;			}					}		/////////		////////////PUBLIC		///////////		public function adjustVolume(vol : Number) : void {			mySound.volume = vol;			stream_ns.soundTransform = mySound;		}				public function removeVideo() : void {			if(contains(video)) {				removeChild(video);			}					}		public function pauseMovie() : void {			stream_ns.pause();		}		public function resumeMovie() : void {			stream_ns.resume();		}		public function playMovieCue(n:uint) : void {			if (n > -1 && n < navigationPoints.length){				currentCueIndex=n;				stream_ns.pause();				stream_ns.seek(navigationPoints[n]);				stream_ns.resume();			}		}		public function clearVideoObject() : void {						if (stream_ns != null)			{				stream_ns.removeEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);				stream_ns.removeEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);				stream_ns.close();				mySound=null;				stream_ns = null;				}			if (connect_nc){				connect_nc.removeEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);				connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);				connect_nc.close();				connect_nc=null;			}			if(video != null) {				if(contains(video)) {					video.clear();					video.attachNetStream(null);					removeChild(video);					video = null;				}			}			if(progressTimer!=null){				progressTimer.removeEventListener(TimerEvent.TIMER, onTick);				progressTimer.stop();				progressTimer=null;			}		}		public function stopMovie() : void {			stream_ns.pause();			stream_ns.seek(0);			progressTimer.stop();		}	}}